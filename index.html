<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>VoxelCraft</title>
<style>
body{margin:0;overflow:hidden;background:#000}
#crosshair{
  position:fixed;left:50%;top:50%;
  transform:translate(-50%,-50%);
  color:white;font-size:18px
}
</style>
</head>
<body>
<div id="crosshair">+</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
// ================= BASIC =================
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(100,200,100);
scene.add(sun);

// ================= INPUT =================
const keys={};
addEventListener("keydown",e=>keys[e.code]=true);
addEventListener("keyup",e=>keys[e.code]=false);
document.body.onclick=()=>document.body.requestPointerLock();

// ================= MOUSE =================
let yaw=0,pitch=0;
addEventListener("mousemove",e=>{
  if(document.pointerLockElement!==document.body)return;
  yaw-=e.movementX*0.002;
  pitch-=e.movementY*0.002;
  pitch=Math.max(-1.4,Math.min(1.4,pitch));
});

// ================= TEXTURES =================
function tex(c1,c2){
  const c=document.createElement("canvas");
  c.width=c.height=16;
  const x=c.getContext("2d");
  x.fillStyle=c1;x.fillRect(0,0,16,16);
  for(let i=0;i<40;i++){
    x.fillStyle=c2;
    x.fillRect(Math.random()*16,Math.random()*16,2,2);
  }
  const t=new THREE.CanvasTexture(c);
  t.magFilter=t.minFilter=THREE.NearestFilter;
  return t;
}
const mats=[
  new THREE.MeshStandardMaterial({map:tex("#3cb371","#2e8b57")}),
  new THREE.MeshStandardMaterial({map:tex("#8b4513","#5c3317")}),
  new THREE.MeshStandardMaterial({map:tex("#888","#666")})
];

// ================= CHUNK SYSTEM =================
const CHUNK=16;
const chunks=new Map();
const blockGeo=new THREE.BoxGeometry(1,1,1);

function chunkKey(cx,cz){return cx+","+cz;}

function height(x,z){
  return Math.floor(Math.sin(x*0.1)*4+Math.cos(z*0.1)*4+8);
}

function generateChunk(cx,cz){
  const group=new THREE.Group();
  const blocks=new Map();

  for(let x=0;x<CHUNK;x++)
  for(let z=0;z<CHUNK;z++){
    const wx=cx*CHUNK+x;
    const wz=cz*CHUNK+z;
    const h=height(wx,wz);
    for(let y=0;y<=h;y++){
      const t=y===h?0:y>h-2?1:2;
      const b=new THREE.Mesh(blockGeo,mats[t]);
      b.position.set(wx,y,wz);
      b.userData={x:wx,y,z:wz};
      group.add(b);
      blocks.set(wx+","+y+","+wz,b);
    }
  }
  scene.add(group);
  chunks.set(chunkKey(cx,cz),{group,blocks});
}

function updateChunks(px,pz){
  const cx=Math.floor(px/CHUNK);
  const cz=Math.floor(pz/CHUNK);
  for(let x=cx-2;x<=cx+2;x++)
  for(let z=cz-2;z<=cz+2;z++){
    if(!chunks.has(chunkKey(x,z))) generateChunk(x,z);
  }
  for(const [k,v] of chunks){
    const [x,z]=k.split(",").map(Number);
    if(Math.abs(x-cx)>3||Math.abs(z-cz)>3){
      scene.remove(v.group);
      chunks.delete(k);
    }
  }
}

// ================= PLAYER =================
const player={
  pos:new THREE.Vector3(0,20,0),
  vel:new THREE.Vector3(),
  size:new THREE.Vector3(0.6,1.8,0.6),
  eye:1.6,
  onGround:false
};

function collide(p){
  for(const ch of chunks.values()){
    for(const b of ch.blocks.values()){
      const d=b.position;
      if(
        Math.abs(p.x-d.x)<0.8 &&
        p.y<d.y+1.8 && p.y+1.8>d.y &&
        Math.abs(p.z-d.z)<0.8
      ) return true;
    }
  }
  return false;
}

// ================= BLOCK BREAK + DROP =================
const ray=new THREE.Raycaster();
const drops=[];

addEventListener("mousedown",()=>{
  ray.setFromCamera(new THREE.Vector2(0,0),camera);
  const hits=ray.intersectObjects(scene.children,true);
  if(hits.length){
    const b=hits[0].object;
    scene.remove(b);
    for(const ch of chunks.values()){
      for(const [k,v] of ch.blocks)
        if(v===b) ch.blocks.delete(k);
    }
    const d=new THREE.Mesh(blockGeo,mats[1]);
    d.position.copy(b.position);
    drops.push(d);
    scene.add(d);
  }
});

// ================= LOOP =================
function loop(){
  requestAnimationFrame(loop);

  camera.rotation.order="YXZ";
  camera.rotation.y=yaw;
  camera.rotation.x=pitch;

  const forward=new THREE.Vector3();
  camera.getWorldDirection(forward);
  forward.y=0;forward.normalize();
  const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0));

  const move=new THREE.Vector3();
  if(keys.KeyW) move.add(forward);
  if(keys.KeyS) move.sub(forward);
  if(keys.KeyA) move.sub(right);
  if(keys.KeyD) move.add(right);

  if(move.lengthSq()){
    move.normalize().multiplyScalar(0.1);
    player.pos.x+=move.x;
    if(collide(player.pos)) player.pos.x-=move.x;
    player.pos.z+=move.z;
    if(collide(player.pos)) player.pos.z-=move.z;
  }

  player.vel.y-=0.02;
  player.pos.y+=player.vel.y;
  if(collide(player.pos)){
    player.pos.y-=player.vel.y;
    player.vel.y=0;
    player.onGround=true;
  } else player.onGround=false;

  if(keys.Space&&player.onGround) player.vel.y=0.35;

  drops.forEach((d,i)=>{
    if(d.position.distanceTo(player.pos)<1){
      scene.remove(d);
      drops.splice(i,1);
    }
  });

  updateChunks(player.pos.x,player.pos.z);

  camera.position.set(player.pos.x,player.pos.y+player.eye,player.pos.z);
  renderer.render(scene,camera);
}
loop();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
