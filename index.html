<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>VoxelCraft</title>
<style>
html,body{margin:0;overflow:hidden;background:#000;font-family:arial}
#cross{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;font-size:20px}
#hotbar{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:6px}
.slot{width:44px;height:44px;border:2px solid #fff;color:#fff;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6)}
.active{border-color:yellow}
</style>
</head>
<body>
<div id="cross">+</div>
<div id="hotbar">
  <div class="slot active">1</div>
  <div class="slot">2</div>
  <div class="slot">3</div>
</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
// ================= SCENE =================
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);
scene.fog=new THREE.Fog(0x87ceeb,20,120);

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,500);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace=THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

// ================= LIGHT =================
scene.add(new THREE.AmbientLight(0xffffff,.45));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(100,150,100);
scene.add(sun);

// ================= INPUT =================
const keys={};
addEventListener("keydown",e=>keys[e.code]=true);
addEventListener("keyup",e=>keys[e.code]=false);
document.body.onclick=()=>document.body.requestPointerLock();

// ================= MOUSE =================
let yaw=0,pitch=0;
addEventListener("mousemove",e=>{
  if(document.pointerLockElement!==document.body)return;
  yaw-=e.movementX*0.002;
  pitch-=e.movementY*0.002;
  pitch=Math.max(-1.5,Math.min(1.5,pitch));
});

// ================= TEXTURES =================
function tex(a,b){
  const c=document.createElement("canvas");
  c.width=c.height=64;
  const x=c.getContext("2d");
  x.fillStyle=a;x.fillRect(0,0,64,64);
  for(let i=0;i<400;i++){
    x.fillStyle=b;
    x.fillRect(Math.random()*64,Math.random()*64,2,2);
  }
  const t=new THREE.CanvasTexture(c);
  t.magFilter=t.minFilter=THREE.NearestFilter;
  return t;
}

const MAT=[
  new THREE.MeshStandardMaterial({map:tex("#3aa655","#2e8b57")}),
  new THREE.MeshStandardMaterial({map:tex("#8b4513","#5c3317")}),
  new THREE.MeshStandardMaterial({map:tex("#888","#666")}),
  new THREE.MeshStandardMaterial({map:tex("#5b3a1e","#3e2614")}),
  new THREE.MeshStandardMaterial({map:tex("#2f7d32","#1e5f25")})
];

// ================= BLOCK SYSTEM =================
const geo=new THREE.BoxGeometry(1,1,1);
const blocks=new Map();
const drops=[];
const key=(x,y,z)=>`${x},${y},${z}`;

function addBlock(x,y,z,t){
  const m=new THREE.Mesh(geo,MAT[t]);
  m.position.set(x,y,z);
  m.userData.type=t;
  scene.add(m);
  blocks.set(key(x,y,z),m);
}

// ================= PLAYER =================
const player={
  pos:new THREE.Vector3(0,30,0),
  vel:new THREE.Vector3(),
  size:new THREE.Vector3(0.6,1.8,0.6),
  eye:1.6,
  onGround:false
};

// ================= NOISE =================
function noise(x,z){
  return Math.sin(x*0.08)+Math.cos(z*0.08)+Math.sin((x+z)*0.04)*2;
}

// ================= WORLD =================
const SIZE=40;
for(let x=-SIZE;x<SIZE;x++)
for(let z=-SIZE;z<SIZE;z++){
  const h=Math.floor(noise(x,z)*3+8);
  for(let y=0;y<=h;y++){
    if(y>2 && Math.sin(x*0.3+y*0.4+z*0.3)>0.7) continue;
    addBlock(x,y,z,y==h?0:y>h-2?1:2);
  }
  if(Math.random()<0.04 && h>7){
    const th=3+Math.floor(Math.random()*3);
    for(let t=1;t<=th;t++) addBlock(x,h+t,z,3);
    for(let lx=-2;lx<=2;lx++)
    for(let lz=-2;lz<=2;lz++)
    for(let ly=th-1;ly<=th+1;ly++)
      if(Math.abs(lx)+Math.abs(lz)<4)
        addBlock(x+lx,h+ly,z+lz,4);
  }
}

// ================= COLLISION =================
function collides(pos){
  const minX=Math.floor(pos.x-player.size.x/2);
  const maxX=Math.floor(pos.x+player.size.x/2);
  const minY=Math.floor(pos.y);
  const maxY=Math.floor(pos.y+player.size.y);
  const minZ=Math.floor(pos.z-player.size.z/2);
  const maxZ=Math.floor(pos.z+player.size.z/2);

  for(let x=minX;x<=maxX;x++)
  for(let y=minY;y<=maxY;y++)
  for(let z=minZ;z<=maxZ;z++)
    if(blocks.has(key(x,y,z))) return true;

  return false;
}

// ================= HOTBAR =================
let selected=0;
const slots=[...document.querySelectorAll(".slot")];
addEventListener("keydown",e=>{
  if(e.key>="1"&&e.key<="3"){
    selected=e.key-1;
    slots.forEach((s,i)=>s.classList.toggle("active",i===selected));
  }
});

// ================= RAYCAST =================
const ray=new THREE.Raycaster();
addEventListener("mousedown",e=>{
  ray.setFromCamera({x:0,y:0},camera);
  const hit=ray.intersectObjects([...blocks.values()])[0];
  if(!hit)return;
  const p=hit.object.position;
  if(e.button===0){
    scene.remove(hit.object);
    blocks.delete(key(p.x,p.y,p.z));

    // DROP
    const d=new THREE.Mesh(geo,MAT[hit.object.userData.type]);
    d.scale.set(.4,.4,.4);
    d.position.copy(p);
    d.userData.vel=Math.random()*0.1;
    scene.add(d);
    drops.push(d);
  }
  if(e.button===2){
    const n=hit.face.normal;
    const x=p.x+n.x,y=p.y+n.y,z=p.z+n.z;
    if(!blocks.has(key(x,y,z))) addBlock(x,y,z,selected);
  }
});
addEventListener("contextmenu",e=>e.preventDefault());

// ================= LOOP =================
function animate(){
  requestAnimationFrame(animate);

  camera.rotation.order="YXZ";
  camera.rotation.y=yaw;
  camera.rotation.x=pitch;

  const forward=new THREE.Vector3();
  camera.getWorldDirection(forward);
  forward.y=0;forward.normalize();
  const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0));

  const speed=keys.ShiftLeft?.15:.08;
  const move=new THREE.Vector3();
  if(keys.KeyW)move.add(forward);
  if(keys.KeyS)move.sub(forward);
  if(keys.KeyA)move.sub(right);
  if(keys.KeyD)move.add(right);
  move.normalize().multiplyScalar(speed);

  // X
  player.pos.x+=move.x;
  if(collides(player.pos)) player.pos.x-=move.x;

  // Z
  player.pos.z+=move.z;
  if(collides(player.pos)) player.pos.z-=move.z;

  // Gravity
  player.vel.y-=0.02;
  player.pos.y+=player.vel.y;
  if(collides(player.pos)){
    player.pos.y-=player.vel.y;
    player.vel.y=0;
    player.onGround=true;
  } else player.onGround=false;

  if(keys.Space&&player.onGround){
    player.vel.y=.35;
    player.onGround=false;
  }

  // DROPS
  for(let i=drops.length-1;i>=0;i--){
    const d=drops[i];
    d.position.y-=0.05;
    if(d.position.distanceTo(player.pos)<1){
      scene.remove(d);
      drops.splice(i,1);
    }
  }

  camera.position.set(
    player.pos.x,
    player.pos.y+player.eye,
    player.pos.z
  );

  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
